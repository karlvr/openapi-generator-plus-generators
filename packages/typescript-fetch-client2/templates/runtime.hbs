{{>header}}

{{>hooks/runtimeImports}}
{{#each servers}}
{{#if @first}}
export const BASE_URI = "{{{url}}}".replace(/\/+$/, "");
{{/if}}
{{/each}}
{{#unless servers}}
export const BASE_URI = "";
{{/unless}}

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
	csv: ",",
	ssv: " ",
	tsv: "\t",
	pipes: "|",
};

/**
 *
 * @export
 * @type FetchAPI
 */
export type FetchAPI = (url: string, init?: RequestInit) => Promise<Response>;

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
	url: string;
	options: RequestInit;
}

/**
 * An unauthorized response from the API. This could be due to missing or invalid authorization credentials.
 */
export interface UnauthorizedResponse {
	status: 'unauthorized'
	response: Response
}

/**
 * An undocumented response from the API. This could be due to an unexpected status code or content
 * type.
 */
export interface UndocumentedResponse {
	status: 'undocumented'
	response: Response
	contentType?: string | undefined
}

/**
 * An error that occured while trying to call the API, such as due to network errors.
 */
export interface FetchErrorResponse {
	status: 'error'
	error: unknown
}

export type UnexpectedResponse = UndocumentedResponse | FetchErrorResponse

export function isUnauthorizedResponse<T>(response: T | UnauthorizedResponse): response is UnauthorizedResponse {
	return response && typeof response === 'object' && 'status' in response && response.status === 'unauthorized'
}

export function isUndocumentedResponse<T>(response: T | UndocumentedResponse): response is UndocumentedResponse {
	return response && typeof response === 'object' && 'status' in response && response.status === 'undocumented'
}

export function isFetchErrorResponse<T>(response: T | FetchErrorResponse): response is FetchErrorResponse {
	return response && typeof response === 'object' && 'status' in response && response.status === 'error'
}

export function isUnexpectedResponse<T>(response: T | UnexpectedResponse): response is UnexpectedResponse {
	return isUndocumentedResponse(response) || isFetchErrorResponse(response)
}

export function isDocumentedResponse<T>(response: T | UnexpectedResponse | UnauthorizedResponse): response is T {
	return !isUnexpectedResponse(response) && !isUnauthorizedResponse(response)
}

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
	constructor(public field: string, msg?: string) {
		super(msg);
		Object.setPrototypeOf(this, RequiredError.prototype);
		this.name = "RequiredError";
	}
}

/* The following characters are legal in URL path segments, but are encoded by `encodeURIComponent`

	From RFC 3986: https://datatracker.ietf.org/doc/html/rfc3986
	segment       = *pchar
	pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
	pct-encoded   = "%" HEXDIG HEXDIG
	unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
	sub-delims    = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="

*/
const URL_PATH_SEGMENT_CHARS = [
/* -- sub-delims -- */
/*	'!',  - Not needed, as this is not encoded by `encodeURIComponent` */
	'$',
	'&',
/*	'\'', - Not needed, as this is not encoded by `encodeURIComponent` */
/*	'(',  - Not needed, as this is not encoded by `encodeURIComponent` */
/*	')',  - Not needed, as this is not encoded by `encodeURIComponent` */
/*	'*',  - Not needed, as this is not encoded by `encodeURIComponent` */
	'+',
	',',
	';',
	'=',
/* -- specific pchars -- */
	':',
	'@',
]
const URL_PATH_SEGMENT_CHAR_MAP = URL_PATH_SEGMENT_CHARS.reduce((acc: Record<string, string>, char) => {
	acc[encodeURIComponent(char)] = char
	return acc
}, {})

/**
 * Similar to `encodeURIComponent`, but does not encode certain characters that are specifically legal
 * in URL path segments, according to RFC 3986: https://datatracker.ietf.org/doc/html/rfc3986
 * 
 * See {@link URL_PATH_SEGMENT_CHARS} for the list of characters that are not encoded.
 * 
 * @export
 */
export function encodeURIPathSegment(segment: string) {
	let result = encodeURIComponent(segment)
	Object.entries(URL_PATH_SEGMENT_CHAR_MAP).forEach(([encoded, char]) => {
		/* This is an alternative to using String.replaceAll, which isn't available in older environments */
		result = result.split(encoded).join(char)
	})
	return result
}

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
export function dateToString(value: Date | string): string

/**
 * We sometimes represent dates as strings (in models) and as Dates (in parameters) so this
 * function converts them both to a string.
 */
export function dateToString(value: Date | string | undefined): string | undefined {
	if (value instanceof Date) {
		return value.toISOString();
	} else if (typeof value === 'string') {
		return value;
	} else {
		return undefined;
	}
}
